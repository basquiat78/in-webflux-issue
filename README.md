# in-webflux-issue

웹플럭스에서 일어날 법한 이슈에 대한 테스트 코드

# 인터뷰중 의문점들

웹플럭스를 토이 프로젝트 수준이나 실제 내부 프로젝트에 사용하면서 어떤 이유로 흐름이 지연되었다가 다량의 데이터가 디비에 한번에 writing이 생긴다던가 `api`요청중에도 이런 현상 발생에 대한 이야기가 오고
갔다.
나는 먼저 1차적으로 Backpressure 매커니즘에 의해 발생하는게 아닐까라고 말을 했는데 이런 현상을 경험해 보지 못했지만 끝나고 이 생각이 머리속에서 계속 맴돌았다.

따라서 여기서는 어떠한 이유로 이러한 현상이 발생하는지에 대한 테스트 케이스를 작성해 볼 생각이다

# 몇 가지 의심이 되는 부분

## 백프레셔로 인한 버퍼 지연

가장 먼저 1차적으로 생각했던 부분이다.
이는 upstream, downstream에 의해서 처리 속도에 대한 문제가 발생할 수 있는데 만일 여기서 차이가 생기면 버퍼가 생긴다.

예상컨데 `db writing` 시점에 아무래도 처리가 늦을 수 있으니 이 현상에 의해 버퍼가 생기다가 해결되면서 버스터가 발생했을 가능성이 높다.

보통 `drain`이라고 표현하는거 같은데 이 부분 체크

## R2DBC Batch

예전에 들었던 이야기중 하나가 R2DBC의 내부 버퍼링의 성능 이슈로 인한 `Batch` 문제였다.
따라서 특정 경계점에 이르면 모았다가 한번에 `db writing`을 한다는 것이다.

1000번의 `save`를 날렸다면 건당 처리하는게 아니라 성능 이슈로 모아서 처리한다는 매커니즘으로 이해할 수 있다.

이것이 정상적인 기능인가는 확인해 봐야 할 체크 포인트

## Transaction 이슈

만일 대량의 데이터를 다룬다고 한다면 `Pseudo Code`로 대충 이런 코드일 확률이 높다.

```java

manyRequestFlux.flatMap(Repository::save);

```

이 경우라면 위에서 언급한 `R2DBC Batch`에 의한 처리 이슈일 수 있다.

## DB 커넥션 풀 이슈

인터뷰중 잠시 언급되었던 이야기이긴 한데 이 부분을 의심해 볼 필요가 있다.

예를 들면 논블록킹이라 하더라도 DB와의 인터랙션이 발생할 때 가용한 커넥션 풀 이슈로 대기하다가 `drain`이 발생한다면?
아마도 `flux backlog`에 의한 자연스러운 현상일 수도...

## 어디선가 블록킹을 한다??

의문점이 들었지만 웹플럭스를 사용한다면 기본적으로 `BlockHound`을 사용할 것이라 생각해서 이 부분은 물어보지 않음

# Next Episode

일단 생각을 먼저 적어보고 퇴근후에 테스트 코드나 케이스를 한번 작성해 볼 생각.

# Test Case

[Branch - Drain And Burst Test](https://github.com/basquiat78/in-webflux-issue/tree/drain-and-burst-test)